专题-动态规划
===

DP 问题的一般思路
---
- 定义 dp
- 初始化 dp
- 更新 dp ——递推公式
- 优化 dp （可选）

Reference
---
- [常见的动态规划问题分析与求解 - 五岳](https://www.cnblogs.com/wuyuegb2312/p/3281264.html) - 博客园 

Index
---
<!-- TOC -->

- [0-1 背包](#0-1-背包)
- [编辑距离](#编辑距离)
- [最长公共子序列](#最长公共子序列)
- [最长递增子序列](#最长递增子序列)
- [最大l连续子序列和/积](#最大l连续子序列和积)
- [矩阵链乘法](#矩阵链乘法)
- [有代价的最短路径](#有代价的最短路径)
- [瓷砖覆盖（状态压缩DP）](#瓷砖覆盖状态压缩dp)
- [工作量划分](#工作量划分)
- [三路取苹果](#三路取苹果)

<!-- /TOC -->

## 0-1 背包

## 编辑距离
> [编辑距离](https://leetcode-cn.com/problems/edit-distance/description/) - LeetCode
**问题描述**
```
给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数。

你可以对一个单词进行如下三种操作：
  插入一个字符
  删除一个字符
  替换一个字符

示例:
  输入: word1 = "horse", word2 = "ros"
  输出: 3
  解释: 
  horse -> rorse (将 'h' 替换为 'r')
  rorse -> rose (删除 'r')
  rose -> ros (删除 'e')
```
- **注意**：编辑距离指的是将 **word1 转换成 word2**

**DP思路**
- 用一个 dp 数组维护两个字符串的**前缀**编辑距离
- 定义 `dp[i][j] := 将 word1 的前 i 个字符转换成 word2 的前 j 个字符需要的操作数`
- 初始化，显然有
  ```
  dp[i][0] = i  // 每次从 word1 删除一个字符
  dp[0][j] = j  // 每次向 word1 插入一个字符
  ```
- 更新 dp
  - word1[i] == word1[j] 时
    ```
    dp[i][j] = dp[i-1][j-1]
    ```
  - word1[i] != word1[j] 时，有三种更新方式，**取最小**
    ```
    dp[i][j] = dp[i-1][j]   + 1   // 向 word1 插入一个字符
             = dp[i][j-1]   + 1   // 从 word1 删除一个字符
             = dp[i-1][j-1] + 1   // 对 word1 替换一个字符
    ```

**Code**
```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length();
        int n = word2.length();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        // 初始化 dp
        for (int i = 1; i <= m; i++)
            dp[i][0] = i;
        for (int j = 1; j <= n; j++)
            dp[0][j] = j;

        // 更新 dp
        for (int i = 1; i <=m; i++)
            for (int j = 1; j <= n; j++)
                if (word1[i - 1] == word2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = min({ dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1 });
            
        return dp[m][n];
    }
};
```

## 最长公共子序列

## 最长递增子序列

## 最大l连续子序列和/积

## 矩阵链乘法

## 有代价的最短路径

## 瓷砖覆盖（状态压缩DP）

## 工作量划分

## 三路取苹果